# -*- coding: utf-8 -*-
"""synchronization_v2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NdsqhAA3Dkm_7vFO3xfTlrhyhp0IBGTz
"""

# -*- coding: utf-8 -*-
"""
synchronization_all_experiments.ipynb

Automatically generated by Colab.

This script synchronizes data for each experiment (1..20) so that
all data is aligned to the same timeline (the gen3 RGB camera time).
It reads 'synchronise_analysis.csv' and outputs 'synchronised_data.csv'
for each experiment.
"""

from google.colab import drive
drive.mount('/content/drive')

import os
import pandas as pd
import numpy as np
import ast
import matplotlib.pyplot as plt

# Common lists used for synchronization
cartesian_t = [
    'timestep_cartesian_pose_bicep',
    'timestep_cartesian_pose_end_effector',
    'timestep_cartesian_pose_forearm',
    'timestep_cartesian_pose_shoulder',
    'timestep_cartesian_pose_spherical_wrist_1',
    'timestep_cartesian_pose_spherical_wrist_2',
    'timestep_cartesian_pose_wheelchair',
    'timestep_cartesian_velocity_bicep',
    'timestep_cartesian_velocity_end_effector',
    'timestep_cartesian_velocity_forearm',
    'timestep_cartesian_velocity_shoulder',
    'timestep_cartesian_velocity_spherical_wrist_1',
    'timestep_cartesian_velocity_spherical_wrist_2',
    'timestep_cartesian_velocity_wheelchair'
]

cartesian = [
    'processed_data_cartesian_pose_bicep',
    'processed_data_cartesian_pose_end_effector',
    'processed_data_cartesian_pose_forearm',
    'processed_data_cartesian_pose_shoulder',
    'processed_data_cartesian_pose_spherical_wrist_1',
    'processed_data_cartesian_pose_spherical_wrist_2',
    'processed_data_cartesian_pose_wheelchair',
    'processed_data_cartesian_velocity_bicep',
    'processed_data_cartesian_velocity_end_effector',
    'processed_data_cartesian_velocity_forearm',
    'processed_data_cartesian_velocity_shoulder',
    'processed_data_cartesian_velocity_spherical_wrist_1',
    'processed_data_cartesian_velocity_spherical_wrist_2',
    'processed_data_cartesian_velocity_wheelchair'
]

imu_t = [
    'timestep_imu_angular_velocity',
    'timestep_imu_linear_acceleration',
    'timestep_imu_orientation'
]
imu = [
    'processed_data_imu_angular_velocity',
    'processed_data_imu_linear_acceleration',
    'processed_data_imu_orientation'
]

joint_t = [
    'timestep_joint_state_back_left_wheel_joint',
    'timestep_joint_state_back_right_wheel_joint',
    'timestep_joint_state_front_left_wheel_joint',
    'timestep_joint_state_front_right_wheel_joint',
    'timestep_joint_state_joint_1',
    'timestep_joint_state_joint_2',
    'timestep_joint_state_joint_3',
    'timestep_joint_state_joint_4',
    'timestep_joint_state_joint_5',
    'timestep_joint_state_joint_6',
    'timestep_joint_state_left_inner_knuckle_finger_tip_joint',
    'timestep_joint_state_right_inner_knuckle_finger_tip_joint',
    'timestep_joint_state_robotiq_85_left_finger_tip_joint',
    'timestep_joint_state_robotiq_85_left_knuckle_joint',
    'timestep_joint_state_robotiq_85_right_finger_tip_joint',
    'timestep_joint_state_robotiq_85_right_knuckle_joint'
]
joint_states = [
    'processed_data_joint_state_back_left_wheel_joint',
    'processed_data_joint_state_back_right_wheel_joint',
    'processed_data_joint_state_front_left_wheel_joint',
    'processed_data_joint_state_front_right_wheel_joint',
    'processed_data_joint_state_joint_1',
    'processed_data_joint_state_joint_2',
    'processed_data_joint_state_joint_3',
    'processed_data_joint_state_joint_4',
    'processed_data_joint_state_joint_5',
    'processed_data_joint_state_joint_6',
    'processed_data_joint_state_left_inner_knuckle_finger_tip_joint',
    'processed_data_joint_state_right_inner_knuckle_finger_tip_joint',
    'processed_data_joint_state_robotiq_85_left_finger_tip_joint',
    'processed_data_joint_state_robotiq_85_left_knuckle_joint',
    'processed_data_joint_state_robotiq_85_right_finger_tip_joint',
    'processed_data_joint_state_robotiq_85_right_knuckle_joint'
]

time_cols = [cartesian_t, imu_t, joint_t]
data_cols = [cartesian, imu, joint_states]

# Process experiments 1..20
for n in range(1, 21):
    print("\n=======================================")
    print(f"PROCESSING EXPERIMENT {n}")
    print("=======================================")

    # CSV file with timing data
    timesheet_csv_path = f'/content/drive/MyDrive/data/organization/picking/pick_mustard/Experiment{n}/synchronise_analysis.csv'

    if not os.path.exists(timesheet_csv_path):
        print(f"File not found, skipping: {timesheet_csv_path}")
        continue

    # Read
    df_s = pd.read_csv(timesheet_csv_path)

    # The reference timeline is from the gen3 RGB camera
    if 'processed_data_cameras_rgb_gen3time' not in df_s.columns:
        print(f"Column 'processed_data_cameras_rgb_gen3time' not found in {timesheet_csv_path}. Skipping.")
        continue

    reference = df_s['processed_data_cameras_rgb_gen3time']

    syn_data = {}

    # Loop over categories: cartesian, imu, joint states
    for group_idx in range(len(time_cols)):
        # For each column/time pair
        for col_idx in range(len(time_cols[group_idx])):
            time_col = time_cols[group_idx][col_idx]   # e.g. 'timestep_cartesian_pose_bicep'
            data_col = data_cols[group_idx][col_idx]   # e.g. 'processed_data_cartesian_pose_bicep'

            if (time_col not in df_s.columns) or (data_col not in df_s.columns):
                # If any column missing, skip
                continue

            # The time series for this data
            be_aligned_time = df_s[time_col]

            # Convert string in cells like "[..., ...]" to actual lists
            df_s[data_col] = df_s[data_col].apply(
                lambda x: ast.literal_eval(x) if isinstance(x, str) else x
            )

            # Each row in 'df_s[data_col]' is e.g. a list [v0, v1, v2, ...]
            # We'll interop each index i across the entire column
            data_len = len(df_s[data_col].iloc[0]) if len(df_s) > 0 else 0

            # For each dimension i in that data
            for i in range(data_len):
                # Extract the i-th element from each row
                be_aligned_values = df_s[data_col].apply(lambda arr: arr[i])

                # Interpolate to match the 'reference'
                aligned_values = np.interp(reference, be_aligned_time, be_aligned_values)

                # Store in syn_data with a unique key
                key_name = f"{data_col}{i}"  # e.g. 'processed_data_cartesian_pose_bicep0'
                syn_data[key_name] = aligned_values

    # Finally, store the reference timeline
    syn_data['sim_time'] = reference

    # Convert dictionary to dataframe
    df_sync = pd.DataFrame(syn_data)

    # Output path
    out_csv_path = f'/content/drive/MyDrive/data/organization/picking/pick_mustard/Experiment{n}/synchronised_data.csv'
    df_sync.to_csv(out_csv_path, index=False)

    print(f"Saved synchronized data for experiment {n} => {out_csv_path}")

print("\nAll experiments (1..20) processed!")
