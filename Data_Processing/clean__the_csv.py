# -*- coding: utf-8 -*-
"""clean_the_csv_v2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dc2mcKL1zBOXGsbY8jgIM-TAixLKi_Br
"""

# -*- coding: utf-8 -*-
"""
clean_the_csv_all_experiments.ipynb

This script cleans CSV files from experiments 1..20 and removes corresponding images.
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import os

def manual_decode(x):
    """
    Decodes strings of the form b'...' into normal strings.
    """
    if isinstance(x, str) and x.startswith("b'") and x.endswith("'"):
        return x[2:-1]
    return x

def is_blank(x):
    """
    Checks if x is a blank string (after trimming).
    """
    return isinstance(x, str) and x.strip() == ''

# Loop through n = 1..20
for n in range(1, 21):
    print(f"\n==================================")
    print(f" PROCESSING EXPERIMENT {n}")
    print(f"==================================")

    # Path to the CSV file
    csv_path = f'/content/drive/MyDrive/data/organization/picking/pick_mustard/Experiment{n}/experiment{n}.csv'

    if not os.path.exists(csv_path):
        print(f"CSV file not found for experiment {n}: {csv_path}")
        continue

    # Read the CSV into a pandas DataFrame
    df = pd.read_csv(csv_path)

    # 1) Decode any b'...' strings
    for col in df.select_dtypes(include=['object', 'string']):
        df[col] = df[col].apply(manual_decode)

    # 2) Identify rows that have NaN or blank cells in any column
    # Create a boolean mask for "NaN or blank" in each cell
    mask_na = df.isna()
    mask_blank = df.applymap(is_blank)
    combined_mask = mask_na | mask_blank

    # Rows to drop (any True in the row's mask)
    rows_to_drop = combined_mask.any(axis=1)
    dropped_indices = df.index[rows_to_drop].tolist()

    print(f"Indices of rows to be dropped (Experiment {n}): {dropped_indices}")

    # Create the cleaned version of the DataFrame
    df_cleaned = df.drop(index=dropped_indices)

    # 3) For each dropped index, delete corresponding images in
    #    {gen3_depth, gen3_rgb, wheelchair_depth, wheelchair_rgb}
    #    The code below assumes row index i corresponds to "frame_{i+1}.png"
    #    Adjust if your indexing differs.
    for idx in dropped_indices:
        frame_number = idx + 1  # because your images are named frame_1, frame_2, ...

        # Build file paths for each camera/depth directory
        gen3_depth_path = f'/content/drive/MyDrive/data/organization/picking/pick_mustard/Experiment{n}/gen3_depth/frame_{frame_number}.png'
        gen3_rgb_path   = f'/content/drive/MyDrive/data/organization/picking/pick_mustard/Experiment{n}/gen3_rgb/frame_{frame_number}.png'
        wheel_depth_path= f'/content/drive/MyDrive/data/organization/picking/pick_mustard/Experiment{n}/wheelchair_depth/frame_{frame_number}.png'
        wheel_rgb_path  = f'/content/drive/MyDrive/data/organization/picking/pick_mustard/Experiment{n}/wheelchair_rgb/frame_{frame_number}.png'

        # Attempt to delete each file if it exists
        for path_to_delete in [gen3_depth_path, gen3_rgb_path, wheel_depth_path, wheel_rgb_path]:
            if os.path.exists(path_to_delete):
                os.remove(path_to_delete)
                print(f"  Deleted image: {path_to_delete}")
            else:
                print(f"  Image not found (skipped): {path_to_delete}")

    # 4) Save the cleaned DataFrame to a new CSV file
    out_csv_path = f'/content/drive/MyDrive/data/organization/picking/pick_mustard/Experiment{n}/data_cleaned.csv'
    df_cleaned.to_csv(out_csv_path, index=False)
    print(f"Cleaned CSV saved for experiment {n}: {out_csv_path}")

print("\nAll experiments processed!")
